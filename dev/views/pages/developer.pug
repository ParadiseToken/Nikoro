extends /layouts/default

block vars
  - var page = "developer";
  - const repoName = github.split("/")[4];

block content
  include /includes/navbar
  
  .container
    section.section
      .columns
        .column.is-3
          aside.menu
            p.menu-label Developer's guide
            ul.menu-list
              li: a(href="#firstplugin") Writing your first plugin
              li: a(href="#architecture") Architecture
              li
                a(href="#plugins") Plugins
                ul
                  li: a(href="#staticGetPlugin"): tt static get plugin()
                  li: a(href="#constructor"): tt constructor(obj)
                  li: a(href="#eventListeners") Event listeners
              li: a(href="#usingAPI") Using the Telegram API
              li: a(href="#proxy") Proxy plugins
              li: a(href="#auth") The Auth helper
              li: a(href="#test") Testing
              li: a(href="#bestpractices") The Auth helper
        .column.is-9
          section#firstplugin
            h3.title Writing your first plugin
            p.
              Are you looking forward to writing a plugin? The Developer's Guide will help you. Here is a list of steps you could follow:
            ol.list
              li.
                Understand the #[a(href="#plugins") general structure of plugins].
              li.
                Develop your plugin, perhaps using #[a(href=github+"/blob/"+projectbranch+"/src/plugins/Echo.js"): tt Echo.js] as a starting point. Refer often to this guide to learn about available features, and take inspiration from similar plugins.
              li.
                Test your plugin's functionality, both by yourself and with other users.
              li.
                Review our #[a(href="#bestpractices") best practices] and apply them to your plugin.
              li
                | If you wish, submit it into the main repository!
                ol.list
                  li.
                    Fork #[a(href=github) our repository] on GitHub.
                  li.
                    Commit your changes, taking care to follow our #[a(href=github+"/blob/"+projectbranch+"/CONTRIBUTING.md") coding standards] which dictate rules on code formatting and commit messages.
                  li.
                    Open a #[a(href=github+"/pulls") pull request].
            br
          section#architecture
            h3.title Architecture
            p
              | This is an overview of the logic flow of messages:
            figure.has-text-centered
              a(href=root+"assets/images/Message_diagram.png", alt="Message flow diagram", title="Open this image in a new tab", target="_blank")
                img(src=root+"assets/images/Message_diagram.png")
            p.
              PluginManager receives Telegram messages, and passes them to the proxy plugins for inspection. If the message is approved by all proxies, it is sent to all plugins, which may decide to reply with a text, picture and so on by interacting directly with the Telegram API.
          section#plugins
            h3.title Plugins
            p.
              In #{projectname}, plugins are #[strong classes that react to specific events from the Telegram API].
            p.
              The general structure is:
            pre: code.js.
              // File: src/plugins/MyPlugin.js
              const Plugin = require("../Plugin");

              module.exports = class MyPlugin extends Plugin {
                // Information about your plugin.
                static get plugin() {
                  return {
                    name: "MyPlugin",
                    description: "It does things.",
                    help: "Try saying 'Hello!', or using the /hello command."
                  }
                }

                // Optional: initialize the plugin.
                constructor(obj) {
                  super(obj);

                  /* ... */
                }

                // Optional: stop the plugin.
                stop() {
                  foo.stop();
                }

                /* Handlers can return a string, representing a text reply;
                 * alternatively, they can return {type: "text", text: "..."} (see Telegram API);
                 * alternatively, they can use this.sendMessage.
                 *
                 * The same goes for eg. pictures (either {type: "photo"} or this.sendPhoto),
                 * music ({type: "audio"}, this.sendAudio) and so on.
                 */
                onCommand({message, command, args}) {
                  if (command === "hello") {
                    return "Heyo!";
                    this.sendMessage(message.chat.id, "Heyo!");
                  }
                }

                // Called when a message is received.
                onText({message}) {
                  if (message === "Hello!") {
                    this.sendMessage(message.chat.id, "Hi!");
                  }
                }

                onPhoto({message}) {
                  /* ... */
                }

                /* ... */
              }
            p.
              As you can see, it is a class that extends Plugin (from #[tt src/Plugin.js]). The metadata is given through #[tt static get plugin()], which #[strong must] be present.
            blockquote#staticGetPlugin
              | Every plugin must have #[tt static get plugin()], which returns an object. At a minimum, it contains:
              ul.list
                li #[tt name]: the plugin's name
                li #[tt description]: a short description (shown in the list of plugins)
                li #[tt help]: a help text (shown in #[kbd /help PluginName])
              | It can include additional properties, which we'll explain later:
              ul.list
                li #[tt isProxy], which says whether this plugin has proxy capabilities or not (default: false)
                li #[tt isHidden], which says whether this plugin is hidden from #[kbd /help] or not (default: false)
            p.
              It optionally features a #[tt constructor], to give you access to rarely-used objects:
            blockquote#constructor
              | #[tt constructor] gets passed a single variable (usually called #[tt obj]), which contains the objects needed to initialize the plugin. They are:
              ul.list
                li config: the bot's configuration
                li auth: an instance of the Auth helper, documented later
              | There are also some properties you shouldn't need:
              ul.list
                li db: the plugin database loaded from disk (you shouldn't need it, it's in #[tt this.db])
                li blacklist: same as above, but with the blacklist (#[tt this.blacklist])
                li emitter: the emitter from PluginManager (can be accessed with #[tt onText], #[tt onMessage] and so on)
                li bot: the TelegramBot object from #[tt node-telegram-bot-api]
            p.
              It also features one or more #[strong event listeners], functions that react to events.
            blockquote#eventListeners
              | An example of event listener is:
              pre: code.js.
                onText({message}) {
                  // Your code here
                }
            p They are functions that are invoked whenever a specific event happens. They take an object argument with the property #[tt message].
            p There are many ways you can react to a message by eg. sending a text message:
            ol
              li You can return a string: #[tt return "Hello there!"]
              li
                | You can return an object with the type of message and its contents:
                pre: code.js.
                  return {
                    type: "text",
                    text: "*Hello* there!",
                    options: { // Optional parameters, see Telegram API
                      parse_mode: "Markdown"
                    }
                  }
                blockquote.
                  Use "audio" for the API method #[tt sendAudio], "document" for #[tt sendDocument], "photo" for #[tt sendPhoto] and so on. "text" is an exception, it uses #[tt sendMessage]. Note that you can't send contacts or locations with this method.
              li #[strong You can return a #[tt Promise]] that returns one of the above:
                pre: code.js.
                  onCommand({command, args}) {
                    const query = args[0];
                    return request("https://google.com/search?q=" + query)
                      .then(text => "The result of your search is:\n\n" + query);
                  }
              li You can use the Telegram API methods, documented below. For example, #[tt this.sendMessage(message.chat.id, "Hello!")].
            p You can find a list of event listeners in #[tt src/Plugins.js]; the general rule is that the listener takes the name of the event (text -> onText, photo -> onPhoto and so on).
          section#usingAPI
            h3.title Using the Telegram API
            p.
              #{projectname} exposes the Telegram API through #[tt: a(href="https://npmjs.com/package/node-telegram-bot-api") node-telegram-bot-api], the methods of which are bound on the Plugin instance. In short, this means that inside a plugin you can simply call #[tt this.sendMessage(...)] and it will work as expected.
            blockquote.
              Note that in #[tt function() { }] blocks, #[tt this] #[strong does not] point to the Plugin instance, so #[tt this.sendMessage] won't work as expected. You should replace them with arrow functions if you wish to use #[tt this].
            p.
              Refer to the #[a(href="https://github.com/yagop/node-telegram-bot-api/blob/release/doc/api.md") NTBA reference] or its #[a(href="https://github.com/yagop/node-telegram-bot-api#usage") documentation] for extended information on how to use it. Here are some of the most common cases:
            pre: code.js.
              // Responding to a message
              onText({message}) {
                if (message.text === "Hello, bot!") {
                  return "Hello, user!";
                }
              }

              // Italic/bold text
              onText({message}) {
                this.sendMessage(message.chat.id, "__Italic__, *bold*", {parse_mode: "Markdown"});
                this.sendMessage(message.chat.id, "&lt;i&gt;Italic&lt;/i&gt;, &lt;b&gt;bold&lt;/b&gt;", {parse_mode: "HTML"});
              }

              // Sending a picture
              onText({message}) {
                this.sendPhoto(message.chat.id, "/home/john/Pictures/paveldurov.jpg", {caption: "This is Pavel Durov."});
              }
            blockquote.
              Note that #[tt sendMessage] (like all send* functions) takes two arguments, the chat ID (or the user ID, if they already initiated a conversation with the bot) and the text.
          section#proxy
            h3.title Proxy plugins
            p.
              #{projectname} supports #[i proxy plugins], i.e. plugins that can approve or reject messages. Approved messages keep going through the bot and plugins; rejected messages are dropped.
            p.
              To configure a plugin as a proxy, simply set #[tt isProxy: true] in #[tt static get plugin()] and implement a #[tt proxy(eventName, message)] method. It will receive every message, returning a rejected Promise (#[tt Promise.reject]) if the message is rejected, and anything else otherwise.
          section#auth
            h3.title The Auth helper
            p.
              Sometimes, you may want to restrict the usage of a command to chat administrators, or viceversa you may want to apply a command differently for normal users and admins (eg. prevent admins from being kicked). For this, you can use the Auth helper, which has methods to determine whether a user is a chat administrator for a specific chat or an owner. You can get it via the constructor:
            pre: code.js.
              constructor(obj) {
                super(obj);

                this.auth = obj.auth;
              }

              onText({message}) {
                if (this.auth.isOwner(message.from.id)) {
                  return "You are an owner!";
                } else if (this.auth.isChatAdmin(message.chat.id, message.from.id)) {
                  return "You are a chat admin!";
                } else {
                  return "You are not an admin, sorry.";
                }
              }
            p.
              It exposes the methods #[tt isChatAdmin(chatID, userID)] to determine whether an user is a chat admin for the given chat or a (global) owner, #[tt isOwner(userID)] to determine if the user is an owner per #[tt config.json], and #[tt getChatAdmins(chatID)]/#[tt getOwners()] to get an array of chat admin and owner user IDs respectively.
          section#test
            h3.title Testing
            p You can test your bot by simply writing to it on Telegram, of course. However, in some situations (eg. requiring multiple accounts) it can be tricky or time-consuming to do so. For this reason, you can use a "mock interface" in #[tt tests/cli.js].

            p It will run your bot in a fake environment, pretending to be Telegram. It will only receive your messages from the console, and the messages it sends are printed to the console. Furthermore, you can use the console to switch between different accounts and groups with a simple command.

            p For further information, send "#help" using the tool.
          section#bestpractices
            h3.title Best practices
            p.
              This is a list of guidelines that plugins should follow in order to be enjoyed by users.
            ul.list
              li.
                Each plugin exists to fulfill one or more needs, be it a need for fun or for a tool. The plugin should fulfill the users' needs with the #[strong minimum number of steps], and possibly #[strong short interactions].
              li.
                Being able to fulfill a task in few steps is part of #[strong keeping it simple]. This principle also means hiding the complexities of a system from the user, exposing a simple interface instead.
              li.
                #[strong Use structured input (buttons) when possible]. This usually makes it as easy as possible to interact with the bot, since it reduces the possibilities to make mistakes.
              li.
                Enforce #[strong authorization checks]. This can be as trivial as not letting a mod kick an admin, but can also be more subtle: for instance, if an action takes two or more steps, it shouldn't be possible for an user to initiate the action and another to continue it.
              li
                | #[strong Provide feedback] for user's actions. For instance, if you're writing the Set plugin, you might want to send the user a confirmation:
                blockquote.
                  #[strong User]: /set Hello Hey there!
                  #[br]
                  #[strong Bot]: Set Hello =&gt; Hey there!
                p Note that in this case, we're not just providing a confirmation, but we're repeating part of the input to confirm the action was understood correctly.
                p On the other hand, you #[strong shouldn't provide redundant feedback]. For instance, if you ask the bot to change the chat title, Telegram will already display a notification, so you shouldn't send an additional message:
                blockquote.
                  #[strong User]: /settitle My favourite chat
                  #[br]
                  #[i Bot changed the chat title to "My favourite chat".]
              li
                | An important part of providing feedback is #[strong handling errors] and informing the user of them. For instance, if you're writing a plugin to change the chat's title, consider the possibility that it doesn't work due to the bot not being an admin:
                blockquote.
                  #[strong User]: /settitle My favourite chat
                  #[br]
                  #[strong Bot]: Couldn't set the chat title: not a chat admin.
                | Note that for Telegram API methods such as #[tt .setChatTitle], this is achieved with promises with a #[tt .catch(error =&gt; {...})] clause.
              li
                | #[strong Use #[tt this.log] sparingly] instead of #[tt console.log]. This allows the bot's owner to stay aware of what their bot is doing, without being overwhelmed with messages. Choose levels accordingly: being unable to kick an user should be logged with #[tt this.log.error], but the user running a query on your plugin (eg. #[kbd /google telegram bots]) is worthy of #[tt this.log.debug] at most.
              li.
                If you use a multi-step process, #[strong provide a way out]. Users may change their minds or decide they "started with the wrong foot"; they should be able to undo the action, and not be stuck in the process.
              li.
                Use standard text messages. Currently, the only standard is returning #[tt Insufficient privileges (chat admin required).] and #[tt Insufficient privileges (owner required).] when a user lacks authorization to run a command.
              li.
                Differentiate between actions that can be run by anyone, commands that are only for chat administrators (because they can be disruptive to the chat, eg. kicking users), and commands that are only for owners (because they can disrupt the operation of the bot, eg. global settings, enabling plugins).
            small.
              Sources: Microsoft's #[a(href="https://docs.microsoft.com/en-us/bot-framework/bot-design-principles") Principles of bot design], Intercom's #[a(href="https://blog.intercom.com/principles-bot-design/") principles of bot design], Facebook's #[a(href="https://developers.facebook.com/docs/messenger-platform/introduction/general-best-practices") Design best practices].
